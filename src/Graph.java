import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * This class stores a graph layout as generated by the cudaLayout program.
 * It reads in the SVG file and reads the embedded comment to work out the graph
 * structure and position of each vertex. Issues of vertex size and edge labels
 * are ignored.
 *
 * @author Roman Klapaukh
 *
 */
public class Graph {

	/**
	 * This map stores the various numeric properties of the
	 * test run
	 */
	private final Map<String, Number> settings;

	/**
	 * This is the input file name that was use to generate this graph layout.
	 * I.e. the original graphml file.
	 */
	private String graphName;

	/**
	 * An adjacency matrix of all the edges in the graph.
	 * Has all the redundant edges so it doesn't matter which order you test in
	 */
	private final boolean[][] edges;

	/**
	 * The 2D coordinates of all of the vertices in the graph.
	 */
	private final Point[] nodes;

	/**
	 * Read in an SVG file created by the cudaLayout project and represent the graph
	 * layout contained in it. Not going to work on any other input.
	 *
	 * @param filename The svg file to read in
	 * @throws IOException Occures when there is an error opening or reading the file
	 *
	 */
	public Graph(String filename) throws IOException {
		settings = new HashMap<String,Number>();
		Scanner scan = new Scanner(new File(filename));

		//Ignore the SVG header
		while (scan.hasNextLine() && !scan.nextLine().equals("<!--"))
			;

		//Read all the fields
		String label = scan.next();
		while(!label.equals("-")){
			label = label.substring(0,label.length()-1); //Trim off :
			if(scan.hasNextLong()){
				settings.put(label, scan.nextLong());
			}else if(scan.hasNextDouble()){
				settings.put(label, scan.nextDouble());
			}else{
				//The only String is the graph file name
				graphName = scan.next();
			}
			label = scan.next();
		}

		//Now read the graph
		label = scan.next(); //Throw away Start
		label = scan.next(); //Throw away Graph:
		int numNodes = scan.nextInt();
		edges = new boolean[numNodes][numNodes];
		nodes = new Point[numNodes];
		for(int i=0 ; i < numNodes; i++){
			//Read in the node
			double x = scan.nextDouble();
			double y = scan.nextDouble();
			nodes[i] = new Point(x, y);

			//Read in its edges
			for(int e= 0 ; e < numNodes; e ++){
				edges[i][e] = scan.nextInt() == 1;
			}
		}

		scan.close();
	}

	/**
	 * The number of nodes there are in the graph
	 * @return Number of nodes
	 */
	public int numNodes(){
		return nodes.length;
	}

	/**
	 * Test for the existence of an edge between two specified Nodes
	 * @param node1 The first node
	 * @param node2 The second node
	 * @return is there an edge connecting node1 and node2
	 */
	public boolean isEdge(int node1, int node2){
		return edges[node1][node2];
	}

	/**
	 * Find the euclidean distance between two nodes in the layout. They do not have to be connected by an
	 * edge.
	 *
	 * @param node1 The first node
	 * @param node2 The second node
	 * @return The distance between the two nodes
	 */
	public double distanceBetween(int node1, int node2){
		return nodes[node1].distanceTo(nodes[node2]);
	}

	/**
	 * The file name that was originally used to create this graph layout.
	 * @return The graphml file used as input to cudaLayout
	 */
	public String graphName(){
		return this.graphName;
	}

	/**
	 * Get one of the fields stored in the SVG. These are all numeric
	 * properties of the layout
	 *
	 * @param s The String used to reference the property
	 * @return The value of the specified property
	 */
	public Number getProperty(String s){
		return settings.get(s);
	}

	/**
	 * Get the coordinates of a given node
	 *
	 * @param n The node index to get the coordinates for
	 * @return The x,y coordinates of the node in the layout
	 *
	 */
	public Point getNode(int n){
		return nodes[n];
	}
}
